**Classification**

classfication(분류)은 회귀 기법과 많은 공통점을 가지고있는 감독적 학습의 형태이다.  일반적으로 머신러닝이 데이터셋을 사용하여 사물에 대한 값이나 이름을 예측하는게 전부라면 분류는 일반적으로 이항분류와 다중클래스 분류라는 두가지 그룹으로 나뉜다.

알고있어야하는 두가지

- 선형회귀 분석은 변수 사이의 관계를 예측하고 새 기준점이 해당 선과 관계가 될 위치를 정확하게 예측하는 데 도움이 된다
- 로지스틱 회귀 분석은 "binary categories"를 발견하는데 도움이 된다

분류는 데이터 포인트의 라벨 또는 클래스를 결정하는 다른 방법을 결정하기 위해 다양한 알고리즘을 사용한다.

요리 자료로 재료 그룹을 관찰하여 원산지를 판단할 수 있는지 알아보자.

**소개**

분류란 머신러닝 연구자와 데이터 과학자들의 근본적인 활동중 하나이다. 기본적 이진 값의 분류부터 컴퓨터 비전을 이용한 복잡한 이미 분류 세분화까지, 데이터를 클래스로 분류하고 이에 대한 질문을 하는게 가능하다.

공정을 보다 과학적으로 셜명하기 위해, 분류방법은 입력변수와 출력변수 사이의 관계를 매핑할 수 있는 예측 모델을 만든다.

이제 머신러닝을 활용하여 데이터를 분류할 수 있는 방법에 대해 알아보자. 

통계에서 파생된 고전적 머신러닝을 사용한 분류는 흡연자, 무게, 나이와 같은 features 를 사용하여 X질병의 발병 가능성을 판단한다.

회귀분석과 유사한 지도학습 기법으로서 데이터는 레이블로 표시되며, ML 알고리즘은 데이터 집합의 클래스를 분류하고 예측하며 그룹이나 결과에 할당하게 된다.



잠시 질문에 답할수 있는지 고민해보자

- 다중 클래스 모델이 답할 수 있는게 무엇인가?
- 이진 모델이 답할 수 있는게 무엇인가?
- 주어진 요리에 fenugreek을 사용할 가능성이 있는지 어떻게 확인 할 수 있는가?
- star anise, artichokes, cauliflower, horseradish로 가득 찬 식료품가방을 선물한다면 전형적인 인도 요리를 만들어낼 수 있는가?



**'분류기'**

이 요리 데이터셋에 묻고싶은 질문은 다중 클래스 질문인데, 우리가 할수 있는 여러 잠재적 국가의 요리가 있기 때문이다. 재료가 한묶음 주어진다면 어느 클래스에 데이터가 들어 맞을까?

사이킷런은 해결할 문제의 종류에 따라 데이터를 분류하는 여러 알고리즘을 제공한다. 이제 이 알고리즘에 대해 학습해보자.

**연습**

데이터 정리 및 균형 조정

이 프로젝트를 시작하기 전에 데이터를 정리하고 균형을 맞추는게 우선이다. 

imblearn은 데이터의 균형을 더 잘 맞출 수 있도록 해주는 사이킷런 패키지이다.
```


```

맨앞 5개의 데이터를 불러와 확인해본다

```
df.head()
```

데이터에 대한 정보를 요약하여 불러온다

```
df.info()
```

 **Exercise**

요리별 데이터의 분포 확인

```
df.cuisine.value_counts().plot.barh()
```

요리의 수가 유한하지만 데이터의 분배는 고르지 않다.  이를 고쳐보자

```
thai_df = df[(df.cuisine == "thai")]
japanese_df = df[(df.cuisine == "japanese")]
chinese_df = df[(df.cuisine == "chinese")]
indian_df = df[(df.cuisine == "indian")]
korean_df = df[(df.cuisine == "korean")]

print(f'thai df: {thai_df.shape}')
print(f'japanese df: {japanese_df.shape}')
print(f'chinese df: {chinese_df.shape}')
print(f'indian df: {indian_df.shape}')
print(f'korean df: {korean_df.shape}')
```




```python
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np
from imblearn.over_sampling import SMOTE
```


```python
#필요한 데이터 불러오기

df  = pd.read_csv('C:/Users/SSS/Documents/GitHub/ML-For-Beginners/4-Classification/data/cuisines.csv')
```


```python
#맨앞 5개의 데이터를 불러와 확인해본다

df.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Unnamed: 0</th>
      <th>cuisine</th>
      <th>almond</th>
      <th>angelica</th>
      <th>anise</th>
      <th>anise_seed</th>
      <th>apple</th>
      <th>apple_brandy</th>
      <th>apricot</th>
      <th>armagnac</th>
      <th>...</th>
      <th>whiskey</th>
      <th>white_bread</th>
      <th>white_wine</th>
      <th>whole_grain_wheat_flour</th>
      <th>wine</th>
      <th>wood</th>
      <th>yam</th>
      <th>yeast</th>
      <th>yogurt</th>
      <th>zucchini</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>65</td>
      <td>indian</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>66</td>
      <td>indian</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>67</td>
      <td>indian</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>68</td>
      <td>indian</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>69</td>
      <td>indian</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 385 columns</p>
</div>




```python
#데이터에 대한 정보를 요약하여 불러온다

df.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 2448 entries, 0 to 2447
    Columns: 385 entries, Unnamed: 0 to zucchini
    dtypes: int64(384), object(1)
    memory usage: 7.2+ MB
    

 **Exercise**


```python
#요리별 데이터의 분포 확인

df.cuisine.value_counts().plot.barh()
```




    <AxesSubplot:>




    
![png](output_6_1.png)
    




요리의 수가 유한하지만 데이터의 분배는 고르지 않다.  이를 고쳐보자


```python

thai_df = df[(df.cuisine == "thai")]
japanese_df = df[(df.cuisine == "japanese")]
chinese_df = df[(df.cuisine == "chinese")]
indian_df = df[(df.cuisine == "indian")]
korean_df = df[(df.cuisine == "korean")]

print(f'thai df: {thai_df.shape}')
print(f'japanese df: {japanese_df.shape}')
print(f'chinese df: {chinese_df.shape}')
print(f'indian df: {indian_df.shape}')
print(f'korean df: {korean_df.shape}')
```

    thai df: (289, 385)
    japanese df: (320, 385)
    chinese df: (442, 385)
    indian df: (598, 385)
    korean df: (799, 385)
    

**재료찾기** 
데이터를 깊이있게 살펴보고 일반적인 요리의 재료가 무엇인지 알아보자
create_ingredient()함수를 만들어 재료의 데이터 프레임을 만들것이다. 이 기능은 도운이 안되는 열을 삭제하고 재료의 수에 따라 정렬한다.


```python
def create_ingredient_df(df):
    ingredient_df = df.T.drop(['cuisine','Unnamed: 0']).sum(axis=1).to_frame('value')
    ingredient_df = ingredient_df[(ingredient_df.T != 0).any()]
    ingredient_df = ingredient_df.sort_values(by='value', ascending=False,
    inplace=False)
    return ingredient_df
```


```python
#barh()로 thai 데이터 나타내기
thai_ingredient_df = create_ingredient_df(thai_df)
thai_ingredient_df.head(10).plot.barh()
```




    <AxesSubplot:>




    
![png](output_12_1.png)
    



```python
#barh()로 일본 데이터 
japanese_ingredient_df = create_ingredient_df(japanese_df)
japanese_ingredient_df.head(10).plot.barh()
```




    <AxesSubplot:>




    
![png](output_13_1.png)
    



```python
#중국
chinese_ingredient_df = create_ingredient_df(chinese_df)
chinese_ingredient_df.head(10).plot.barh()
```




    <AxesSubplot:>




    
![png](output_14_1.png)
    



```python
#한국
korean_ingredient_df = create_ingredient_df(korean_df)
korean_ingredient_df.head(10).plot.barh()
```




    <AxesSubplot:>




    
![png](output_15_1.png)
    


drop() 을 사용하여 요리간의 혼동을 야기하는 일반적 재료를 삭제해보자.
보통 거의 쌀, 마늘, 생강은 좋아한다.



```python
feature_df= df.drop(['cuisine','Unnamed: 0','rice','garlic','ginger'], axis=1)
labels_df = df.cuisine #.unique()
feature_df.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>almond</th>
      <th>angelica</th>
      <th>anise</th>
      <th>anise_seed</th>
      <th>apple</th>
      <th>apple_brandy</th>
      <th>apricot</th>
      <th>armagnac</th>
      <th>artemisia</th>
      <th>artichoke</th>
      <th>...</th>
      <th>whiskey</th>
      <th>white_bread</th>
      <th>white_wine</th>
      <th>whole_grain_wheat_flour</th>
      <th>wine</th>
      <th>wood</th>
      <th>yam</th>
      <th>yeast</th>
      <th>yogurt</th>
      <th>zucchini</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 380 columns</p>
</div>



**데이터셋의 균형**
SMOTE를 사용하여 균형맞추기


```python
#fit_resample()호출
oversample = SMOTE()
transformed_feature_df, transformed_label_df = oversample.fit_resample(feature_df, labels_df)
```

데이터의 균형을 맞추면 데이터를 분류할 때 더 나은 결과를 얻을 수 있다. 


```python
print(f'new label count: {transformed_label_df.value_counts()}')
print(f'old label count: {df.cuisine.value_counts()}')
```

    new label count: indian      799
    thai        799
    chinese     799
    japanese    799
    korean      799
    Name: cuisine, dtype: int64
    old label count: korean      799
    indian      598
    chinese     442
    japanese    320
    thai        289
    Name: cuisine, dtype: int64
    

위의 데이터는 깔끔하게 정리되어있다.
마지막 단계는 labels와 features를 포함한 균형잡힌 데이터를 저장하는 것이다.



```python
transformed_df = pd.concat([transformed_label_df,transformed_feature_df],axis=1, join='outer')
```

transformed_df.head() 과 transformed_df.info()를 사용하여 데이터를 한번에 볼 수 있다.


```python
transformed_df.head()
transformed_df.info()
transformed_df.to_csv("C:/Users/SSS/Documents/GitHub/ML-For-Beginners/4-Classification/data/cleaned_cuisines.csv")
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 3995 entries, 0 to 3994
    Columns: 381 entries, cuisine to zucchini
    dtypes: int64(380), object(1)
    memory usage: 11.6+ MB
    

**요리 분류기1**
위의 균형잡힌 데이터를 사용하여 여러 재료들을 바탕으로 주어진 국가의 요리를 예측해보자.
그러는 동안 분류 작업에 알고리즘이 활용될 수 있는 몇가지 방법에 대해서 알아보자.

**연습** 국가별 요리 예측



```python
import pandas as pd
cuisines_df = pd.read_csv("C:/Users/SSS/Documents/GitHub/ML-For-Beginners/4-Classification/data/cleaned_cuisines.csv")
cuisines_df.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Unnamed: 0</th>
      <th>cuisine</th>
      <th>almond</th>
      <th>angelica</th>
      <th>anise</th>
      <th>anise_seed</th>
      <th>apple</th>
      <th>apple_brandy</th>
      <th>apricot</th>
      <th>armagnac</th>
      <th>...</th>
      <th>whiskey</th>
      <th>white_bread</th>
      <th>white_wine</th>
      <th>whole_grain_wheat_flour</th>
      <th>wine</th>
      <th>wood</th>
      <th>yam</th>
      <th>yeast</th>
      <th>yogurt</th>
      <th>zucchini</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>indian</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>indian</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>indian</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>indian</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>indian</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 382 columns</p>
</div>




```python
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.metrics import accuracy_score,precision_score,confusion_matrix,classification_report, precision_recall_curve
from sklearn.svm import SVC
import numpy as np
```


```python
# 훈련을 위해 X와Y를 나눈다
cuisines_label_df = cuisines_df['cuisine']
cuisines_label_df.head()
```




    0    indian
    1    indian
    2    indian
    3    indian
    4    indian
    Name: cuisine, dtype: object




```python
# 0번열과 요리 열을 drop()하기
cuisines_feature_df = cuisines_df.drop(['Unnamed: 0', 'cuisine'], axis=1)
cuisines_feature_df.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>almond</th>
      <th>angelica</th>
      <th>anise</th>
      <th>anise_seed</th>
      <th>apple</th>
      <th>apple_brandy</th>
      <th>apricot</th>
      <th>armagnac</th>
      <th>artemisia</th>
      <th>artichoke</th>
      <th>...</th>
      <th>whiskey</th>
      <th>white_bread</th>
      <th>white_wine</th>
      <th>whole_grain_wheat_flour</th>
      <th>wine</th>
      <th>wood</th>
      <th>yam</th>
      <th>yeast</th>
      <th>yogurt</th>
      <th>zucchini</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 380 columns</p>
</div>



**분류기 선택**

데이터를 훈련할 수 있게 준비시켜놨기에 이제 훈련에 사용할 알고리즘을 결정해야한다.
사이킷런의 분류기법에는 다음이 있다
- Linear Models
- Support Vector Machines
- Stochastic Gradient Descent
- Nearest Neighbors
- Gaussian Processes
- Decision Trees
- Ensemble methods (voting Classifier)
- Multiclass and multioutput algorithms

가장 좋은 접근은 다운로드 가능한 ML Cheat sheet를 따르는 것이다. 

**Reasoning**
우리가 가지고 있는 제약조건에 따라 서로 다른 접근방식을 통해 우리의 길을 설득할 수 있는지 알아보자.

- 신경망이 너무 무겁다. 깨끗하고 최소한의 데이터 세트와 노트북을 통해 로컬로 훈련을 진행하고 있다는 사실을 감안할 때 신경망은 이 작업에 비해 너무 무겁다.
- 2class 분류기가 없다.우리는 2종류 분류기를 사용하지 않는다. 그래서 1-v-all을 배제한다.
- 의사결정 트리 또는 로지스틱 회귀 분석이 작동할 수 있다.의사결정 트리가 작동하거나 다중클래스 데이터에 대해 로지스틱 회귀 분석이 가능할 수 있다.
- 다중 클래스 강화 의사결정 트리들은 다른 문제를 해결한다.다중 클래스 부스트 결정 트리는 비모수 작업에 가장 적합하기 때문에 우리에게 유용하지 않다.

**데이터 분할**


```python
#train_test_split()을 사용해 훈련셋 테스트셋 나누기
X_train, X_test, y_train, y_test = train_test_split(cuisines_feature_df, cuisines_label_df, test_size=0.3)
```


```python
#로지스틱 회귀로 훈련하기
lr = LogisticRegression(multi_class='ovr',solver='liblinear')
model = lr.fit(X_train, np.ravel(y_train))

accuracy = model.score(X_test, y_test)
print ("Accuracy is {}".format(accuracy))
```

    Accuracy is 0.7964970809007507
    


```python
#하나의 행을 선택하여 테스트해보기
print(f'ingredients: {X_test.iloc[50][X_test.iloc[50]!=0].keys()}')
print(f'cuisine: {y_test.iloc[50]}')
```

    ingredients: Index(['chicken', 'sake', 'soy_sauce'], dtype='object')
    cuisine: japanese
    

더 깊게 파고들어 예측의 정확도를 체크해보기


```python
test= X_test.iloc[50].values.reshape(-1, 1).T
proba = model.predict_proba(test)
classes = model.classes_
resultdf = pd.DataFrame(data=proba, columns=classes)

topPrediction = resultdf.T.sort_values(by=[0], ascending = [False])
topPrediction.head()
```

    C:\Users\SSS\anaconda3\envs\py3_7_6\lib\site-packages\sklearn\base.py:451: UserWarning: X does not have valid feature names, but LogisticRegression was fitted with feature names
      "X does not have valid feature names, but"
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>japanese</th>
      <td>0.751300</td>
    </tr>
    <tr>
      <th>chinese</th>
      <td>0.178929</td>
    </tr>
    <tr>
      <th>korean</th>
      <td>0.035216</td>
    </tr>
    <tr>
      <th>thai</th>
      <td>0.032867</td>
    </tr>
    <tr>
      <th>indian</th>
      <td>0.001689</td>
    </tr>
  </tbody>
</table>
</div>



분류 리포트를 프린트하여 자세한 정보를 확인


```python
y_pred = model.predict(X_test)
print(classification_report(y_test,y_pred))
```

                  precision    recall  f1-score   support
    
         chinese       0.71      0.69      0.70       217
          indian       0.89      0.92      0.90       237
        japanese       0.78      0.74      0.76       269
          korean       0.83      0.77      0.80       243
            thai       0.77      0.86      0.81       233
    
        accuracy                           0.80      1199
       macro avg       0.80      0.80      0.79      1199
    weighted avg       0.80      0.80      0.80      1199
    
    

**요리 분류기2**
-Exercise

**데이터 분할**


```python
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.metrics import accuracy_score,precision_score,confusion_matrix,classification_report, precision_recall_curve
import numpy as np
```


```python
#데이터셋 훈련셋과 테스트셋으로 나누기
X_train, X_test, y_train, y_test = train_test_split(cuisines_feature_df, cuisines_label_df, test_size=0.3)
```

**Linear SVC분류기**
SVC는  SVM의 하위부분이다.
이 메서드에서 우린 kernel을 선택하여 label을 군집화하는 방법을 결정할 수 있다.
kernel은 여러개중 하나일 수 있다. 

**Exercise- 선형 SVC 적용**


```python
C = 10
# 다른 분류기 만들기
classifiers = {
    'Linear SVC': SVC(kernel='linear', C=C, probability=True,random_state=0)
}
```


```python
#선형 SVC모델 훈련
n_classifiers = len(classifiers)

for index, (name, classifier) in enumerate(classifiers.items()):
    classifier.fit(X_train, np.ravel(y_train))

    y_pred = classifier.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    print("Accuracy (train) for %s: %0.1f%% " % (name, accuracy * 100))
    print(classification_report(y_test,y_pred))
```

    Accuracy (train) for Linear SVC: 77.6% 
                  precision    recall  f1-score   support
    
         chinese       0.66      0.72      0.69       240
          indian       0.88      0.90      0.89       254
        japanese       0.78      0.73      0.76       240
          korean       0.85      0.73      0.79       224
            thai       0.73      0.79      0.76       241
    
        accuracy                           0.78      1199
       macro avg       0.78      0.77      0.78      1199
    weighted avg       0.78      0.78      0.78      1199
    
    

**k-최근접이웃 분류기**
 k-최근접이웃은 지도/비지도 학습에 모두 사용될 수 있다. 이 방법에서 먼저 정의된 수의 포인터가 데이터를 생성하고 주변 데이터를 수집한다.
 

'KNN classifier': KNeighborsClassifier(C),


Accuracy (train) for KNN classifier: 73.8% 
              precision    recall  f1-score   support

     chinese       0.64      0.67      0.66       242
      indian       0.86      0.78      0.82       234
    japanese       0.66      0.83      0.74       254
      korean       0.94      0.58      0.72       242
        thai       0.71      0.82      0.76       227

    accuracy                           0.74      1199
   macro avg       0.76      0.74      0.74      1199
weighted avg       0.76      0.74      0.74      1199

**SVC**
SVC는 SVM의 일부이다. 두 종류 사이의 거리를 최대화 하기 위해서 공간의 지정된 포인트에 훈련 예를 매핑함

'SVC': SVC(),

Accuracy (train) for SVC: 83.2% 
              precision    recall  f1-score   support

     chinese       0.79      0.74      0.76       242
      indian       0.88      0.90      0.89       234
    japanese       0.87      0.81      0.84       254
      korean       0.91      0.82      0.86       242
        thai       0.74      0.90      0.81       227

    accuracy                           0.83      1199
   macro avg       0.84      0.83      0.83      1199
weighted avg       0.84      0.83      0.83      1199

**Ensemble분류기**
랜덤포레스트 및 AdaBoost사용

 'RFST': RandomForestClassifier(n_estimators=100),
  'ADA': AdaBoostClassifier(n_estimators=100)

Accuracy (train) for RFST: 84.5% 
              precision    recall  f1-score   support

     chinese       0.80      0.77      0.78       242
      indian       0.89      0.92      0.90       234
    japanese       0.86      0.84      0.85       254
      korean       0.88      0.83      0.85       242
        thai       0.80      0.87      0.83       227

    accuracy                           0.84      1199
   macro avg       0.85      0.85      0.84      1199
weighted avg       0.85      0.84      0.84      1199

Accuracy (train) for ADA: 72.4% 
              precision    recall  f1-score   support

     chinese       0.64      0.49      0.56       242
      indian       0.91      0.83      0.87       234
    japanese       0.68      0.69      0.69       254
      korean       0.73      0.79      0.76       242
        thai       0.67      0.83      0.74       227

    accuracy                           0.72      1199
   macro avg       0.73      0.73      0.72      1199
weighted avg       0.73      0.72      0.72      1199

**요리추천 웹 앱 개발**
위에서 사용된 요리 데이터셋을 사용하여 분류 모델 작성하기. 추가적으로 Onnx의 웹 런타임을 활용하여 저장된 모델을 사용할 수 있는 작은 웹 앱 구축하기

**Exercise - train classification model**


```python
!pip install skl2onnx
import pandas as pd 
```

    Collecting skl2onnx
      Downloading skl2onnx-1.11.1-py3-none-any.whl (276 kB)
    Requirement already satisfied: scikit-learn>=0.19 in c:\users\sss\anaconda3\envs\py3_7_6\lib\site-packages (from skl2onnx) (1.0.2)
    Collecting onnx>=1.2.1
      Downloading onnx-1.11.0-cp37-cp37m-win_amd64.whl (11.2 MB)
    Requirement already satisfied: scipy>=1.0 in c:\users\sss\anaconda3\envs\py3_7_6\lib\site-packages (from skl2onnx) (1.7.3)
    Requirement already satisfied: numpy>=1.15 in c:\users\sss\anaconda3\envs\py3_7_6\lib\site-packages (from skl2onnx) (1.21.5)
    Collecting onnxconverter-common>=1.7.0
      Downloading onnxconverter_common-1.9.0-py2.py3-none-any.whl (78 kB)
    Requirement already satisfied: protobuf in c:\users\sss\anaconda3\envs\py3_7_6\lib\site-packages (from skl2onnx) (3.19.4)
    Requirement already satisfied: typing-extensions>=3.6.2.1 in c:\users\sss\anaconda3\envs\py3_7_6\lib\site-packages (from onnx>=1.2.1->skl2onnx) (4.1.1)
    Requirement already satisfied: threadpoolctl>=2.0.0 in c:\users\sss\anaconda3\envs\py3_7_6\lib\site-packages (from scikit-learn>=0.19->skl2onnx) (3.1.0)
    Requirement already satisfied: joblib>=0.11 in c:\users\sss\anaconda3\envs\py3_7_6\lib\site-packages (from scikit-learn>=0.19->skl2onnx) (1.1.0)
    Installing collected packages: onnx, onnxconverter-common, skl2onnx
    Successfully installed onnx-1.11.0 onnxconverter-common-1.9.0 skl2onnx-1.11.1
    


```python
data = pd.read_csv('C:/Users/SSS/Documents/GitHub/ML-For-Beginners/4-Classification/data/cleaned_cuisines.csv')
data.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Unnamed: 0</th>
      <th>cuisine</th>
      <th>almond</th>
      <th>angelica</th>
      <th>anise</th>
      <th>anise_seed</th>
      <th>apple</th>
      <th>apple_brandy</th>
      <th>apricot</th>
      <th>armagnac</th>
      <th>...</th>
      <th>whiskey</th>
      <th>white_bread</th>
      <th>white_wine</th>
      <th>whole_grain_wheat_flour</th>
      <th>wine</th>
      <th>wood</th>
      <th>yam</th>
      <th>yeast</th>
      <th>yogurt</th>
      <th>zucchini</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>indian</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>indian</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>indian</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>indian</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>indian</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 382 columns</p>
</div>




```python
#불필요한 1,2열을 지우고 남은 데이터를 X에 저장
X = data.iloc[:,2:]
X.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>almond</th>
      <th>angelica</th>
      <th>anise</th>
      <th>anise_seed</th>
      <th>apple</th>
      <th>apple_brandy</th>
      <th>apricot</th>
      <th>armagnac</th>
      <th>artemisia</th>
      <th>artichoke</th>
      <th>...</th>
      <th>whiskey</th>
      <th>white_bread</th>
      <th>white_wine</th>
      <th>whole_grain_wheat_flour</th>
      <th>wine</th>
      <th>wood</th>
      <th>yam</th>
      <th>yeast</th>
      <th>yogurt</th>
      <th>zucchini</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 380 columns</p>
</div>




```python
#label을 y에 저장
y = data[['cuisine']]
y.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>cuisine</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>indian</td>
    </tr>
    <tr>
      <th>1</th>
      <td>indian</td>
    </tr>
    <tr>
      <th>2</th>
      <td>indian</td>
    </tr>
    <tr>
      <th>3</th>
      <td>indian</td>
    </tr>
    <tr>
      <th>4</th>
      <td>indian</td>
    </tr>
  </tbody>
</table>
</div>



**SVC라이브러리를 사용한 훈련루틴**


```python
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.model_selection import cross_val_score
from sklearn.metrics import accuracy_score,precision_score,confusion_matrix,classification_report
```


```python
#훈련셋과 테스트셋 나누기
X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.3)
```


```python
#SVC분류기 모델 구축
model = SVC(kernel='linear', C=10, probability=True,random_state=0)
model.fit(X_train,y_train.values.ravel())
```




    SVC(C=10, kernel='linear', probability=True, random_state=0)




```python
#모델을 테스트해보자
y_pred = model.predict(X_test)
```


```python
print(classification_report(y_test,y_pred))
```

                  precision    recall  f1-score   support
    
         chinese       0.67      0.70      0.68       254
          indian       0.88      0.83      0.86       236
        japanese       0.73      0.71      0.72       216
          korean       0.89      0.78      0.83       240
            thai       0.73      0.84      0.78       253
    
        accuracy                           0.77      1199
       macro avg       0.78      0.77      0.77      1199
    weighted avg       0.78      0.77      0.77      1199
    
    

**모델을 Onnx로 변환**
적절한 Tensor번호로 변환하기. 데이터 집합에 380개의 성분이 나열되어 있으므로 그 숫자를 FloatTensorType에 표기


```python
from skl2onnx import convert_sklearn
from skl2onnx.common.data_types import FloatTensorType

initial_type = [('float_input', FloatTensorType([None, 380]))]
options = {id(model): {'nocl': True, 'zipmap': False}}
```


```python
#onx를 만들어 model.onnx 파일을 저장
onx = convert_sklearn(model, initial_types=initial_type, options=options)
with open("./model.onnx", "wb") as f:
    f.write(onx.SerializeToString())
```

**모델 보기**
netron소프트 웨어를 사용하여 모델을 시각화하여 제대로 제작되었는지 확인하기

**추천자 웹 어플 개발**
웹 앱에서 직접 모델을 사용할 수 있다.이 아키텍처는 필요할 경우 로컬에서 그리고 오프라인에서도 실행할 수 있게 해준다.
model.onnx파일을 저장한 폴더에 index.html파일을 생성한다
<!DOCTYPE html>
<html>
    <header>
        <title>Cuisine Matcher</title>
    </header>
    <body>
        ...
    </body>
</html>


body태그의 일부 성분을 반영하는 확인란 목록을 표시하는 마크업 추가.

        <div id="wrapper">
            <div class="boxCont">
                <input type="checkbox" value="4" class="checkbox">
                <label>apple</label>
            </div>
        
            <div class="boxCont">
                <input type="checkbox" value="247" class="checkbox">
                <label>pear</label>
            </div>
        
            <div class="boxCont">
                <input type="checkbox" value="77" class="checkbox">
                <label>cherry</label>
            </div>

            <div class="boxCont">
                <input type="checkbox" value="126" class="checkbox">
                <label>fenugreek</label>
            </div>

            <div class="boxCont">
                <input type="checkbox" value="302" class="checkbox">
                <label>sake</label>
            </div>

            <div class="boxCont">
                <input type="checkbox" value="327" class="checkbox">
                <label>soy sauce</label>
            </div>

            <div class="boxCont">
                <input type="checkbox" value="112" class="checkbox">
                <label>cumin</label>
            </div>
        </div>
        <div style="padding-top:10px">
            <button onClick="startInference()">What kind of cuisine can you make?</button>
        </div> 

onnx런타임 import하기
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.9.0/dist/ort.min.js"></script> 

<script>
    const ingredients = Array(380).fill(0);
    
    const checks = [...document.querySelectorAll('.checkbox')];
    
    checks.forEach(check => {
        check.addEventListener('change', function() {
            // toggle the state of the ingredient
            // based on the checkbox's value (1 or 0)
            ingredients[check.value] = check.checked ? 1 : 0;
        });
    });

    function testCheckboxes() {
        // validate if at least one checkbox is checked
        return checks.some(check => check.checked);
    }

    async function startInference() {

        let atLeastOneChecked = testCheckboxes()

        if (!atLeastOneChecked) {
            alert('Please select at least one ingredient.');
            return;
        }
        try {
            // create a new session and load the model.
            
            const session = await ort.InferenceSession.create('./model.onnx');

            const input = new ort.Tensor(new Float32Array(ingredients), [1, 380]);
            const feeds = { float_input: input };

            // feed inputs and run
            const results = await session.run(feeds);

            // read from results
            alert('You can enjoy ' + results.label.data[0] + ' cuisine today!')

        } catch (e) {
            console.log(`failed to inference ONNX model`);
            console.error(e);
        }
    }
           
</script>

script>
    const ingredients = Array(380).fill(0);
    
    const checks = [...document.querySelectorAll('.checkbox')];
    
    checks.forEach(check => {
        check.addEventListener('change', function() {
            // toggle the state of the ingredient
            // based on the checkbox's value (1 or 0)
            ingredients[check.value] = check.checked ? 1 : 0;
        });
    });

    function testCheckboxes() {
        // validate if at least one checkbox is checked
        return checks.some(check => check.checked);
    }

    async function startInference() {

        let atLeastOneChecked = testCheckboxes()

        if (!atLeastOneChecked) {
            alert('Please select at least one ingredient.');
            return;
        }
        try {
            // create a new session and load the model.
            
            const session = await ort.InferenceSession.create('./model.onnx');

            const input = new ort.Tensor(new Float32Array(ingredients), [1, 380]);
            const feeds = { float_input: input };

            // feed inputs and run
            const results = await session.run(feeds);

            // read from results
            alert('You can enjoy ' + results.label.data[0] + ' cuisine today!')

        } catch (e) {
            console.log(`failed to inference ONNX model`);
            console.error(e);
        }
    }
           
</script>

이 코드에서 다음 몇가지의 일이 일어난다.
1. 1또는0의 380개의 배열을 생성하고 추론을 위해 모델에 보낸다. 체크박스의 선택 여부에 따라서 작동
2. 체크박스의 배열을 만들고 어플이 시작될때 init 기능을 체크하는지 확인하는것을 만든다
3. testCheckboxes 함수를 만들어 체크박스가 체크되었는지 확인
4. startInference()기능을 체크박스가 눌렸을때 사용한다.
